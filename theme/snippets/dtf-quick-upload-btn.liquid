{% liquid
  assign btn_text = button_text | default: 'Upload Design'
  assign section_id = section.id | default: 'main'
  assign unique_id = section_id | append: '-' | append: product.id
  assign modal_id = 'ul-modal-' | append: unique_id
  assign first_variant = product.selected_or_first_available_variant
  assign api_base = '/apps/customizer'
  assign shop_domain = shop.permanent_domain
%}

<!-- Upload Button -->
<button type="button" class="ul-quick-btn-trigger" data-modal="{{ modal_id }}" style="
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
  padding: 12px 20px;
  border: none;
  border-radius: 8px;
  font-size: 14px;
  font-weight: 600;
  cursor: pointer;
  text-decoration: none;
  width: 100%;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  line-height: 1.4;
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
  font-family: inherit;
">
  <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
    <polyline points="17 8 12 3 7 8"></polyline>
    <line x1="12" y1="3" x2="12" y2="15"></line>
  </svg>
  <span>{{ btn_text }}</span>
</button>

<!-- Modal Template (will be moved to body) -->
<template id="{{ modal_id }}-tpl">
<div id="{{ modal_id }}" class="ul-quick-modal" data-api-base="{{ api_base }}" data-shop="{{ shop_domain }}" data-product-id="{{ product.id }}" data-unique-id="{{ unique_id }}" data-customer-id="{{ customer.id | default: '' }}" data-customer-email="{{ customer.email | default: '' }}">
  <div class="ul-quick-modal-overlay" data-close="{{ modal_id }}"></div>
  <div class="ul-quick-modal-content">
    <button class="ul-quick-modal-close" data-close="{{ modal_id }}">&times;</button>
    
    <!-- Step 1: Upload & Options -->
    <div id="{{ modal_id }}-step1" class="ul-modal-step">
      <div class="ul-quick-modal-header">
        <img src="{{ product.featured_image | image_url: width: 80 }}" alt="{{ product.title }}" class="ul-quick-modal-thumb">
        <div>
          <h3>{{ product.title }}</h3>
          <div class="ul-price-wrapper">
            <span class="ul-unit-price" id="ul-unit-price-{{ unique_id }}">{{ first_variant.price | money }}</span>
            <span class="ul-price-multiply" id="ul-price-multiply-{{ unique_id }}"></span>
          </div>
          <p class="ul-total-price" id="ul-total-price-{{ unique_id }}">{{ first_variant.price | money }}</p>
        </div>
      </div>
      
      <div class="ul-quick-modal-body">
        <!-- Upload Area -->
        <div class="ul-quick-dropzone" id="ul-dropzone-{{ unique_id }}">
          <svg width="40" height="40" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
            <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
            <polyline points="17 8 12 3 7 8"/>
            <line x1="12" y1="3" x2="12" y2="15"/>
          </svg>
          <p><strong>Click to upload</strong></p>
          <span>PNG, JPG, WEBP, TIFF, PSD, PDF, AI, EPS (Max 1GB)</span>
          <input type="file" id="ul-file-{{ unique_id }}" accept=".png,.jpg,.jpeg,.webp,.tiff,.tif,.psd,.svg,.pdf,.ai,.eps" style="display:none">
        </div>
        
        <!-- Upload Progress -->
        <div id="ul-progress-{{ unique_id }}" class="ul-upload-progress" style="display:none;">
          <div class="ul-progress-bar">
            <div class="ul-progress-fill" id="ul-progress-fill-{{ unique_id }}"></div>
          </div>
          <div class="ul-progress-info">
            <p id="ul-progress-text-{{ unique_id }}">Uploading...</p>
            <button type="button" class="ul-cancel-btn" id="ul-cancel-{{ unique_id }}" data-cancel="{{ unique_id }}">
              <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18 6L6 18M6 6l12 12" stroke-linecap="round"/>
              </svg>
              Cancel
            </button>
          </div>
        </div>
        
        <!-- Preview (after upload) -->
        <div id="ul-preview-{{ unique_id }}" class="ul-quick-preview" style="display:none;">
          <img id="ul-preview-img-{{ unique_id }}" src="" alt="Preview">
          <div class="ul-preview-info">
            <span id="ul-preview-name-{{ unique_id }}"></span>
            <span id="ul-preview-status-{{ unique_id }}" class="ul-status-badge"></span>
            <span id="ul-preview-duration-{{ unique_id }}" class="ul-upload-duration" style="display:none;"></span>
          </div>
          <button type="button" data-clear="{{ unique_id }}" data-modal="{{ modal_id }}">&times;</button>
        </div>
        
        <!-- DPI Warning -->
        <div id="ul-dpi-warning-{{ unique_id }}" class="ul-dpi-warning" style="display:none;">
          <svg width="16" height="16" viewBox="0 0 24 24" fill="currentColor"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 15h-2v-2h2v2zm0-4h-2V7h2v6z"/></svg>
          <span id="ul-dpi-text-{{ unique_id }}"></span>
        </div>

        <!-- Variants -->
        {% if product.has_only_default_variant == false %}
          <div class="ul-variants-section">
            {% for option in product.options_with_values %}
              <div class="ul-variant-group">
                <label>{{ option.name }}</label>
                <select id="ul-option-{{ unique_id }}-{{ forloop.index0 }}" class="ul-variant-select">
                  {% for value in option.values %}
                    <option value="{{ value | escape }}" {% if option.selected_value == value %}selected{% endif %}>{{ value }}</option>
                  {% endfor %}
                </select>
              </div>
            {% endfor %}
          </div>
        {% endif %}

        <!-- Quantity -->
        <div class="ul-quantity-section">
          <label>Quantity</label>
          <div class="ul-quantity-wrapper">
            <button type="button" data-qty="{{ unique_id }}" data-delta="-1">−</button>
            <input type="number" id="ul-qty-{{ unique_id }}" value="1" min="1" max="99">
            <button type="button" data-qty="{{ unique_id }}" data-delta="1">+</button>
          </div>
        </div>

        <!-- Hidden fields -->
        <input type="hidden" id="ul-variant-{{ unique_id }}" value="{{ first_variant.id }}" data-price="{{ first_variant.price }}">
        <input type="hidden" id="ul-upload-id-{{ unique_id }}" value="">
        <input type="hidden" id="ul-upload-url-{{ unique_id }}" value="">
        
        <!-- Variant data for JS - MUST be inside template to move with modal -->
        <script type="application/json" id="ul-variants-{{ unique_id }}">
          {{ product.variants | json }}
        </script>
      </div>
      
      <div class="ul-quick-modal-footer">
        <button type="button" class="ul-quick-btn-primary" id="ul-addcart-{{ unique_id }}" data-add-cart="{{ unique_id }}" data-modal="{{ modal_id }}" disabled>
          <span class="ul-btn-text">Add to Cart</span>
          <span class="ul-btn-loading" style="display:none;">Adding...</span>
        </button>
        <p class="ul-upload-hint" id="ul-hint-{{ unique_id }}">Please upload your design first</p>
      </div>
    </div>

    <!-- Step 2: Success -->
    <div id="{{ modal_id }}-step2" class="ul-modal-step" style="display:none;">
      <div class="ul-success-content">
        <div class="ul-success-icon">✓</div>
        <h3>Added to Cart!</h3>
        <p>Your custom design has been uploaded and added to cart.</p>
      </div>
      
      <div class="ul-quick-modal-footer ul-success-buttons">
        <button type="button" class="ul-btn-secondary" data-close="{{ modal_id }}">
          Continue Shopping
        </button>
        <a href="/checkout" class="ul-quick-btn-primary">
          Checkout
        </a>
      </div>
    </div>
  </div>
</div>
</template>

<!-- Styles -->
<style>
.ul-quick-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  z-index: 99999;
  display: none;
  align-items: center;
  justify-content: center;
}
.ul-quick-modal-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0,0,0,0.6);
  backdrop-filter: blur(4px);
}
.ul-quick-modal-content {
  position: relative;
  background: white;
  border-radius: 16px;
  width: 90%;
  max-width: 420px;
  max-height: 90vh;
  overflow: hidden;
  display: flex;
  flex-direction: column;
  box-shadow: 0 20px 60px rgba(0,0,0,0.3);
  animation: modalSlideIn 0.3s ease;
}
.ul-modal-step {
  display: flex;
  flex-direction: column;
  max-height: 100%;
  overflow: hidden;
}
.ul-quick-modal-body {
  padding: 20px;
  flex: 1;
  overflow-y: auto;
  overflow-x: hidden;
}
@keyframes modalSlideIn {
  from { opacity: 0; transform: translateY(20px) scale(0.95); }
  to { opacity: 1; transform: translateY(0) scale(1); }
}
.ul-quick-modal-close {
  position: absolute;
  top: 12px;
  right: 12px;
  width: 32px;
  height: 32px;
  border: none;
  background: #f3f4f6;
  border-radius: 50%;
  font-size: 20px;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  color: #6b7280;
  z-index: 10;
}
.ul-quick-modal-close:hover { background: #e5e7eb; }
.ul-quick-modal-header {
  display: flex;
  align-items: center;
  gap: 16px;
  padding: 20px;
  border-bottom: 1px solid #e5e7eb;
  flex-shrink: 0;
}
.ul-quick-modal-thumb {
  width: 60px;
  height: 60px;
  object-fit: cover;
  border-radius: 8px;
}
.ul-quick-modal-header h3 {
  margin: 0 0 4px 0;
  font-size: 16px;
  color: #1f2937;
}
.ul-price-wrapper {
  display: flex;
  align-items: center;
  gap: 6px;
  flex-wrap: wrap;
}
.ul-unit-price {
  font-size: 13px;
  color: #6b7280;
}
.ul-price-multiply {
  font-size: 12px;
  color: #9ca3af;
}
.ul-total-price {
  margin: 2px 0 0 0;
  font-size: 18px;
  font-weight: 700;
  color: #667eea;
  transition: all 0.2s ease;
}
.ul-total-price.updating {
  transform: scale(1.05);
  color: #764ba2;
}
.ul-quick-dropzone {
  border: 2px dashed #d1d5db;
  border-radius: 12px;
  padding: 24px 20px;
  text-align: center;
  cursor: pointer;
  transition: all 0.2s;
  background: #f9fafb;
}
.ul-quick-dropzone:hover {
  border-color: #667eea;
  background: rgba(102,126,234,0.05);
}
.ul-quick-dropzone svg {
  color: #9ca3af;
  margin-bottom: 8px;
}
.ul-quick-dropzone p {
  margin: 0 0 4px 0;
  font-size: 14px;
  color: #374151;
}
.ul-quick-dropzone span {
  font-size: 12px;
  color: #9ca3af;
}
.ul-upload-progress {
  padding: 20px;
  text-align: center;
  background: #f9fafb;
  border-radius: 12px;
}
.ul-progress-bar {
  height: 6px;
  background: #e5e7eb;
  border-radius: 3px;
  overflow: hidden;
  margin-bottom: 10px;
}
.ul-progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #667eea, #764ba2);
  width: 0%;
  transition: width 0.3s ease;
}
.ul-upload-progress p {
  margin: 0;
  font-size: 13px;
  color: #6b7280;
  flex: 1;
}
.ul-progress-info {
  display: flex;
  align-items: center;
  justify-content: space-between;
  gap: 12px;
}
.ul-cancel-btn {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  padding: 6px 12px;
  background: transparent;
  border: 1px solid #ef4444;
  color: #ef4444;
  border-radius: 6px;
  font-size: 12px;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}
.ul-cancel-btn:hover {
  background: #ef4444;
  color: white;
}
.ul-cancel-btn svg {
  width: 14px;
  height: 14px;
}
.ul-quick-preview {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 12px;
  background: #f0fdf4;
  border: 1px solid #86efac;
  border-radius: 8px;
}
.ul-quick-preview img {
  width: 48px;
  height: 48px;
  object-fit: cover;
  border-radius: 6px;
}
.ul-quick-preview img.loading-spinner {
  object-fit: contain;
  background: #f3f4f6;
  padding: 4px;
}
.ul-preview-info {
  flex: 1;
  overflow: hidden;
}
.ul-preview-info span:first-child {
  display: block;
  font-size: 13px;
  color: #166534;
  overflow: hidden;
  text-overflow: ellipsis;
  white-space: nowrap;
}
.ul-status-badge {
  display: inline-block;
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 10px;
  margin-top: 4px;
}
.ul-status-badge.processing { background: #fef3c7; color: #92400e; }
.ul-status-badge.ready { background: #d1fae5; color: #065f46; }
.ul-status-badge.warning { background: #fef3c7; color: #92400e; }
.ul-status-badge.error { background: #fee2e2; color: #991b1b; }
.ul-upload-duration {
  display: block;
  font-size: 11px;
  color: #059669;
  margin-top: 2px;
}
.ul-quick-preview > button {
  width: 24px;
  height: 24px;
  border: none;
  background: #dc2626;
  color: white;
  border-radius: 50%;
  cursor: pointer;
  font-size: 14px;
  flex-shrink: 0;
}
.ul-dpi-warning {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 10px 12px;
  background: #fef3c7;
  border-radius: 8px;
  margin-top: 12px;
  color: #92400e;
  font-size: 12px;
}
.ul-dpi-warning svg { flex-shrink: 0; }
.ul-variants-section {
  margin-top: 16px;
}
.ul-variant-group {
  margin-bottom: 12px;
}
.ul-variant-group label {
  display: block;
  font-size: 13px;
  font-weight: 600;
  color: #374151;
  margin-bottom: 6px;
}
.ul-variant-select {
  width: 100%;
  padding: 10px 12px;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  font-size: 14px;
  background: white;
  cursor: pointer;
}
.ul-variant-select:focus {
  outline: none;
  border-color: #667eea;
  box-shadow: 0 0 0 3px rgba(102,126,234,0.1);
}
.ul-quantity-section {
  margin-top: 16px;
}
.ul-quantity-section label {
  display: block;
  font-size: 13px;
  font-weight: 600;
  color: #374151;
  margin-bottom: 6px;
}
.ul-quantity-wrapper {
  display: flex;
  align-items: center;
  gap: 0;
  width: fit-content;
  border: 1px solid #d1d5db;
  border-radius: 8px;
  overflow: hidden;
}
.ul-quantity-wrapper button {
  width: 40px;
  height: 40px;
  border: none;
  background: #f3f4f6;
  font-size: 18px;
  cursor: pointer;
  color: #374151;
}
.ul-quantity-wrapper button:hover { background: #e5e7eb; }
.ul-quantity-wrapper input {
  width: 50px;
  height: 40px;
  border: none;
  text-align: center;
  font-size: 15px;
  font-weight: 600;
  -moz-appearance: textfield;
}
.ul-quantity-wrapper input::-webkit-outer-spin-button,
.ul-quantity-wrapper input::-webkit-inner-spin-button {
  -webkit-appearance: none;
}
.ul-quick-modal-footer {
  padding: 16px 20px;
  border-top: 1px solid #e5e7eb;
  flex-shrink: 0;
  background: white;
}
.ul-quick-btn-primary {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100%;
  padding: 14px 20px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white !important;
  text-align: center;
  text-decoration: none !important;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  font-family: inherit;
}
.ul-quick-btn-primary:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
.ul-quick-btn-primary:not(:disabled):hover {
  box-shadow: 0 4px 15px rgba(102,126,234,0.4);
}
.ul-btn-secondary {
  display: block;
  width: 100%;
  padding: 14px 20px;
  background: #f3f4f6;
  color: #374151;
  text-align: center;
  text-decoration: none;
  border: none;
  border-radius: 8px;
  font-weight: 600;
  font-size: 14px;
  cursor: pointer;
  margin-bottom: 10px;
  font-family: inherit;
}
.ul-btn-secondary:hover { background: #e5e7eb; }
.ul-upload-hint {
  text-align: center;
  font-size: 12px;
  color: #9ca3af;
  margin: 10px 0 0 0;
}
.ul-success-content {
  padding: 40px 20px;
  text-align: center;
}
.ul-success-icon {
  width: 60px;
  height: 60px;
  background: #10b981;
  color: white;
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 28px;
  margin: 0 auto 16px;
}
.ul-success-content h3 {
  margin: 0 0 8px 0;
  font-size: 20px;
  color: #1f2937;
}
.ul-success-content p {
  margin: 0;
  color: #6b7280;
  font-size: 14px;
}
.ul-success-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.ul-success-buttons .ul-btn-secondary { margin: 0; }
</style>

<!-- JavaScript - Full API Integration with Event Delegation -->
<script>
(function() {
  console.log('[UL Quick Upload] Script starting...');
  
  // Prevent multiple initializations
  if (window.ULQuickUploadInit) {
    console.log('[UL Quick Upload] Already initialized, skipping');
    return;
  }
  window.ULQuickUploadInit = true;
  console.log('[UL Quick Upload] Initializing...');
  
  // Track active XHR requests for cancel support
  const activeUploads = {};
  
  // Hide all modals function (for theme editor events)
  function hideAllModals() {
    document.querySelectorAll('.ul-quick-modal').forEach(function(modal) {
      modal.style.display = 'none';
    });
    document.body.style.overflow = '';
  }
  
  // Theme editor events - hide modals when sections/blocks are selected/deselected
  document.addEventListener('shopify:section:select', hideAllModals);
  document.addEventListener('shopify:section:deselect', hideAllModals);
  document.addEventListener('shopify:section:load', hideAllModals);
  document.addEventListener('shopify:section:unload', hideAllModals);
  document.addEventListener('shopify:block:select', hideAllModals);
  document.addEventListener('shopify:block:deselect', hideAllModals);
  document.addEventListener('shopify:inspector:activate', hideAllModals);
  document.addEventListener('shopify:inspector:deactivate', hideAllModals);
  
  // Modal container in body
  let modalContainer = document.getElementById('ul-modal-container');
  if (!modalContainer) {
    modalContainer = document.createElement('div');
    modalContainer.id = 'ul-modal-container';
    document.body.appendChild(modalContainer);
  }
  
  // Move modals from templates to body
  let isInitializing = false;
  
  function initModals() {
    console.log('[UL Quick Upload] initModals called');
    
    // Prevent re-entry during initialization
    if (isInitializing) {
      console.log('[UL Quick Upload] Already initializing, skipping');
      return;
    }
    isInitializing = true;
    
    // Collect templates first, then process (to avoid mutation during iteration)
    const templates = Array.from(document.querySelectorAll('template[id$="-tpl"]:not([data-moved])'));
    console.log('[UL Quick Upload] Found templates:', templates.length, templates.map(t => t.id));
    
    if (templates.length === 0) {
      console.log('[UL Quick Upload] No templates to move');
      isInitializing = false;
      return;
    }
    
    // Disconnect observer before DOM mutations
    if (observer) observer.disconnect();
    
    templates.forEach(tpl => {
      console.log('[UL Quick Upload] Moving template:', tpl.id);
      // Mark as moved immediately
      tpl.dataset.moved = 'true';
      
      // Clone content and append to body container
      const content = tpl.content.cloneNode(true);
      modalContainer.appendChild(content);
      console.log('[UL Quick Upload] Template moved to body');
      
      // CRITICAL: Remove original template from section to prevent duplicate modals
      tpl.remove();
    });
    
    // Re-connect observer after all DOM updates complete
    if (observer) {
      setTimeout(() => {
        observer.observe(document.body, { childList: true, subtree: true });
      }, 100);
    }
    
    isInitializing = false;
  }
  
  // Initialize on DOM ready and after dynamic content
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initModals);
  } else {
    initModals();
  }
  
  // Re-init for dynamically loaded content - watch entire subtree for dynamic sections
  let observer = null;
  
  // Debounced init to prevent rapid re-calls
  let initTimeout = null;
  function debouncedInit() {
    if (initTimeout) clearTimeout(initTimeout);
    initTimeout = setTimeout(initModals, 300);
  }
  
  observer = new MutationObserver((mutations) => {
    // Check if any new templates were added anywhere in the DOM
    const hasNewTemplates = mutations.some(m => {
      // Direct template addition
      if (Array.from(m.addedNodes).some(n => n.nodeName === 'TEMPLATE' && n.id?.endsWith('-tpl'))) {
        return true;
      }
      // Template inside added container (sections, etc)
      return Array.from(m.addedNodes).some(n => n.querySelector && n.querySelector('template[id$="-tpl"]'));
    }
    );
    if (hasNewTemplates) {
      debouncedInit();
    }
  });
  observer.observe(document.body, { childList: true, subtree: true });
  
  // Event delegation for all clicks
  document.addEventListener('click', function(e) {
    const target = e.target;
    console.log('[UL Quick Upload] Click detected on:', target.tagName, target.className);
    
    // Open modal button - highest priority
    const openBtn = target.closest('.ul-quick-btn-trigger');
    if (openBtn) {
      console.log('[UL Quick Upload] Open button clicked, modal:', openBtn.dataset.modal);
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
      const modalId = openBtn.dataset.modal;
      openModal(modalId);
      return;
    }
    
    // Close button (X) - second priority
    const closeX = target.closest('.ul-quick-modal-close');
    if (closeX) {
      e.preventDefault();
      e.stopPropagation();
      const modal = closeX.closest('.ul-quick-modal');
      if (modal) closeModal(modal.id);
      return;
    }
    
    // Overlay click - only if clicking directly on overlay (not bubbled from content)
    const overlay = target.closest('.ul-quick-modal-overlay');
    if (overlay && target === overlay) {
      e.preventDefault();
      e.stopPropagation();
      const modalId = overlay.dataset.close;
      closeModal(modalId);
      return;
    }
    
    // Continue Shopping / other close buttons
    const closeBtn = target.closest('[data-close]');
    if (closeBtn && !closeBtn.classList.contains('ul-quick-modal-overlay')) {
      e.preventDefault();
      e.stopPropagation();
      const modalId = closeBtn.dataset.close;
      closeModal(modalId);
      return;
    }
    
    // Add to cart
    const addCartBtn = target.closest('[data-add-cart]');
    if (addCartBtn && !addCartBtn.disabled) {
      e.preventDefault();
      e.stopPropagation();
      const uniqueId = addCartBtn.dataset.addCart;
      const modalId = addCartBtn.dataset.modal;
      addToCart(uniqueId, modalId);
      return;
    }
    
    // Dropzone click
    const dropzone = target.closest('.ul-quick-dropzone');
    if (dropzone) {
      const fileInput = dropzone.querySelector('input[type="file"]');
      if (fileInput) fileInput.click();
      return;
    }
    
    // Clear upload
    const clearBtn = target.closest('[data-clear]');
    if (clearBtn) {
      const uniqueId = clearBtn.dataset.clear;
      const modalId = clearBtn.dataset.modal;
      clearUpload(uniqueId, modalId);
      return;
    }
    
    // Quantity buttons
    const qtyBtn = target.closest('[data-qty]');
    if (qtyBtn) {
      const uniqueId = qtyBtn.dataset.qty;
      const delta = parseInt(qtyBtn.dataset.delta) || 0;
      changeQty(uniqueId, delta);
      return;
    }
    
    // Cancel upload button
    const cancelBtn = target.closest('[data-cancel]');
    if (cancelBtn) {
      const uniqueId = cancelBtn.dataset.cancel;
      cancelUpload(uniqueId);
      return;
    }
  });
  
  // File input change
  document.addEventListener('change', function(e) {
    if (e.target.matches('.ul-quick-dropzone input[type="file"]')) {
      const input = e.target;
      const dropzone = input.closest('.ul-quick-dropzone');
      const uniqueId = dropzone.id.replace('ul-dropzone-', '');
      const modal = input.closest('.ul-quick-modal');
      handleUpload(input, uniqueId, modal);
      return;
    }
    
    // Variant select change - check by class or by ID pattern
    const isVariantSelect = e.target.matches('.ul-variant-select') || 
                            (e.target.tagName === 'SELECT' && e.target.id && e.target.id.startsWith('ul-option-'));
    
    if (isVariantSelect) {
      const select = e.target;
      const id = select.id;
      console.log('[Upload Lift] Variant select changed:', id);
      
      // Extract uniqueId: ul-option-{uniqueId}-{optionIndex}
      // uniqueId can contain dashes, so we need to find the last dash followed by a number
      const lastDashIndex = id.lastIndexOf('-');
      if (lastDashIndex > 10) { // 'ul-option-' is 10 chars
        const uniqueId = id.substring(10, lastDashIndex); // Skip 'ul-option-' prefix
        console.log('[Upload Lift] Extracted uniqueId:', uniqueId);
        updateVariant(uniqueId);
      }
    }
  });
  
  // Also listen for 'input' event as fallback for some browsers/themes
  document.addEventListener('input', function(e) {
    if (e.target.tagName === 'SELECT' && e.target.id && e.target.id.startsWith('ul-option-')) {
      const id = e.target.id;
      const lastDashIndex = id.lastIndexOf('-');
      if (lastDashIndex > 10) {
        const uniqueId = id.substring(10, lastDashIndex);
        updateVariant(uniqueId);
      }
    }
  });
  
  // Track recently opened modals to prevent immediate close from bubbling
  let recentlyOpenedModal = null;
  let openTimestamp = 0;
  
  function openModal(id) {
    console.log('[UL Quick Upload] openModal called with id:', id);
    
    // Don't open modal in Shopify theme editor/preview mode
    if (window.Shopify && window.Shopify.designMode) {
      console.log('[UL Quick Upload] Design mode detected, modal disabled');
      return;
    }
    
    const modal = document.getElementById(id);
    console.log('[UL Quick Upload] Modal element found:', !!modal);
    
    if (!modal) {
      console.error('[UL Quick Upload] Modal not found:', id);
      // Debug: List all modals in the page
      const allModals = document.querySelectorAll('.ul-quick-modal');
      console.log('[UL Quick Upload] All modals in page:', allModals.length, Array.from(allModals).map(m => m.id));
      return;
    }
    
    // Prevent re-opening if already open
    if (modal.style.display === 'flex') return;
    
    // Mark as recently opened to prevent event bubbling close
    recentlyOpenedModal = id;
    openTimestamp = Date.now();
    
    // Use requestAnimationFrame to ensure click event has finished bubbling
    requestAnimationFrame(() => {
      modal.style.display = 'flex';
      document.body.style.overflow = 'hidden';
      const step1 = document.getElementById(id + '-step1');
      const step2 = document.getElementById(id + '-step2');
      if (step1) step1.style.display = 'block';
      if (step2) step2.style.display = 'none';
      
      // Sync variant selection on modal open
      const uniqueId = modal.dataset.uniqueId;
      if (uniqueId) {
        console.log('[Upload Lift] Modal opened, syncing variant for:', uniqueId);
        updateVariant(uniqueId);
      }
      
      // Clear the recently opened flag after a short delay
      setTimeout(() => {
        if (recentlyOpenedModal === id) {
          recentlyOpenedModal = null;
        }
      }, 300);
    });
  }
  
  function closeModal(id) {
    // Prevent closing if modal was just opened (event bubbling protection)
    if (recentlyOpenedModal === id && (Date.now() - openTimestamp) < 200) {
      console.log('[Upload Lift] Ignoring close - modal just opened');
      return;
    }
    
    const modal = document.getElementById(id);
    if (modal) {
      modal.style.display = 'none';
      document.body.style.overflow = '';
    }
  }
  
  async function handleUpload(input, uniqueId, modal) {
    const file = input.files[0];
    if (!file) return;
    
    const apiBase = modal.dataset.apiBase;
    const shopDomain = modal.dataset.shop;
    const productId = modal.dataset.productId;
    const customerId = modal.dataset.customerId || null;
    const customerEmail = modal.dataset.customerEmail || null;
    
    const dropzone = document.getElementById('ul-dropzone-' + uniqueId);
    const progress = document.getElementById('ul-progress-' + uniqueId);
    const progressFill = document.getElementById('ul-progress-fill-' + uniqueId);
    const progressText = document.getElementById('ul-progress-text-' + uniqueId);
    const preview = document.getElementById('ul-preview-' + uniqueId);
    const previewImg = document.getElementById('ul-preview-img-' + uniqueId);
    const previewName = document.getElementById('ul-preview-name-' + uniqueId);
    const previewStatus = document.getElementById('ul-preview-status-' + uniqueId);
    const addBtn = document.getElementById('ul-addcart-' + uniqueId);
    const hint = document.getElementById('ul-hint-' + uniqueId);
    const uploadIdInput = document.getElementById('ul-upload-id-' + uniqueId);
    const uploadUrlInput = document.getElementById('ul-upload-url-' + uniqueId);
    const dpiWarning = document.getElementById('ul-dpi-warning-' + uniqueId);
    const dpiText = document.getElementById('ul-dpi-text-' + uniqueId);
    
    if (!dropzone || !progress) return;
    
    // Show progress
    dropzone.style.display = 'none';
    progress.style.display = 'block';
    progressFill.style.width = '10%';
    progressText.textContent = 'Getting upload URL...';
    
    // Get MIME type with fallback for unsupported types (PSD, AI, EPS etc.)
    const mimeType = file.type || 'application/octet-stream';
    
    // Get visitor tracking info (from ul-visitor.js)
    const visitorId = window.ULVisitor?.getVisitorId?.() || null;
    const sessionId = window.ULVisitor?.getSessionId?.() || null;
    
    try {
      // Step 1: Get upload intent
      const intentResponse = await fetch(`${apiBase}/api/upload/intent`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          shopDomain: shopDomain,
          productId: productId,
          mode: 'quick',
          contentType: mimeType,
          fileName: file.name,
          fileSize: file.size,
          customerId: customerId,
          customerEmail: customerEmail,
          visitorId: visitorId,
          sessionId: sessionId
        })
      });
      
      if (!intentResponse.ok) {
        const errData = await intentResponse.json().catch(() => ({}));
        throw new Error(errData.error || 'Failed to get upload URL');
      }
      const intentData = await intentResponse.json();
      const { uploadId, itemId, uploadUrl, storageProvider, uploadHeaders, publicUrl, key } = intentData;
      
      // Progress tracking variables
      const startTime = Date.now();
      const totalBytes = file.size;
      
      progressFill.style.width = '30%';
      progressText.textContent = 'Uploading... 0%';
      
      // Step 2: Upload file with progress tracking (XHR for progress events)
      let uploadResponse;
      if (storageProvider === 'bunny' || storageProvider === 'r2') {
        // Direct PUT to CDN storage with progress
        uploadResponse = await new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          
          // Store XHR for cancel support
          activeUploads[uniqueId] = xhr;
          
          xhr.upload.onprogress = (e) => {
            if (e.lengthComputable) {
              const percent = Math.round((e.loaded / e.total) * 100);
              const elapsed = (Date.now() - startTime) / 1000;
              const speed = elapsed > 0 ? e.loaded / elapsed : 0;
              const remaining = speed > 0 ? (e.total - e.loaded) / speed : 0;
              
              // Update progress bar (30% to 80% range for upload phase)
              progressFill.style.width = `${Math.min(30 + (percent * 0.5), 80)}%`;
              
              const speedMB = (speed / (1024 * 1024)).toFixed(1);
              const remainingSec = Math.ceil(remaining);
              
              if (remainingSec > 60) {
                progressText.textContent = `Uploading... ${percent}% • ${speedMB} MB/s • ~${Math.ceil(remainingSec/60)}m remaining`;
              } else if (remainingSec > 0) {
                progressText.textContent = `Uploading... ${percent}% • ${speedMB} MB/s • ~${remainingSec}s remaining`;
              } else {
                progressText.textContent = `Uploading... ${percent}%`;
              }
            }
          };
          
          xhr.onload = () => resolve({ ok: xhr.status >= 200 && xhr.status < 300, status: xhr.status });
          xhr.onerror = () => reject(new Error('Network error during upload'));
          xhr.ontimeout = () => reject(new Error('Upload timeout'));
          
          xhr.open('PUT', uploadUrl);
          xhr.setRequestHeader('Content-Type', mimeType);
          if (uploadHeaders) {
            Object.entries(uploadHeaders).forEach(([k, v]) => xhr.setRequestHeader(k, v));
          }
          xhr.send(file);
        });
      } else {
        // Local storage with progress - POST with FormData
        uploadResponse = await new Promise((resolve, reject) => {
          const xhr = new XMLHttpRequest();
          const formData = new FormData();
          formData.append('file', file);
          formData.append('key', key);
          formData.append('uploadId', uploadId);
          formData.append('itemId', itemId);
          
          // Store XHR for cancel support
          activeUploads[uniqueId] = xhr;
          
          xhr.upload.onprogress = (e) => {
            if (e.lengthComputable) {
              const percent = Math.round((e.loaded / e.total) * 100);
              const elapsed = (Date.now() - startTime) / 1000;
              const speed = elapsed > 0 ? e.loaded / elapsed : 0;
              const remaining = speed > 0 ? (e.total - e.loaded) / speed : 0;
              
              // Update progress bar (30% to 80% range for upload phase)
              progressFill.style.width = `${Math.min(30 + (percent * 0.5), 80)}%`;
              
              const speedMB = (speed / (1024 * 1024)).toFixed(1);
              const remainingSec = Math.ceil(remaining);
              
              if (remainingSec > 60) {
                progressText.textContent = `Uploading... ${percent}% • ${speedMB} MB/s • ~${Math.ceil(remainingSec/60)}m remaining`;
              } else if (remainingSec > 0) {
                progressText.textContent = `Uploading... ${percent}% • ${speedMB} MB/s • ~${remainingSec}s remaining`;
              } else {
                progressText.textContent = `Uploading... ${percent}%`;
              }
            }
          };
          
          xhr.onload = () => resolve({ ok: xhr.status >= 200 && xhr.status < 300, status: xhr.status });
          xhr.onerror = () => reject(new Error('Network error during upload'));
          xhr.ontimeout = () => reject(new Error('Upload timeout'));
          
          xhr.open('POST', uploadUrl);
          xhr.send(formData);
        });
      }
      
      if (!uploadResponse.ok) throw new Error('Upload failed');
      
      // Clear active upload reference
      delete activeUploads[uniqueId];
      
      progressFill.style.width = '60%';
      progressText.textContent = 'Processing...';
      
      // Step 3: Complete upload (provider-aware)
      const uploadDurationMs = Date.now() - startTime;
      const completeResponse = await fetch(`${apiBase}/api/upload/complete`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          uploadId: uploadId,
          shopDomain: shopDomain,
          items: [{
            itemId: itemId,
            location: 'front',
            fileUrl: publicUrl || null,
            storageProvider: storageProvider || 'local',
            uploadDurationMs: uploadDurationMs
          }]
        })
      });
      
      if (!completeResponse.ok) throw new Error('Failed to complete upload');
      
      progressFill.style.width = '80%';
      progressText.textContent = 'Analyzing...';
      
      // Store upload ID
      if (uploadIdInput) uploadIdInput.value = uploadId;
      
      // Poll for status and get the signed download URL from API
      let status = 'processing';
      let attempts = 0;
      let finalDownloadUrl = null;
      
      while (status === 'processing' && attempts < 10) {
        await new Promise(r => setTimeout(r, 1000));
        try {
          const statusResponse = await fetch(`${apiBase}/api/upload/status/${uploadId}?shopDomain=${shopDomain}`);
          if (statusResponse.ok) {
            const statusData = await statusResponse.json();
            status = statusData.status;
            // Get the signed URL from API response (this is the correct format)
            if (statusData.downloadUrl) {
              finalDownloadUrl = statusData.downloadUrl;
            }
            if (statusData.preflight?.dpi && statusData.preflight.dpi < 150 && dpiWarning && dpiText) {
              dpiWarning.style.display = 'flex';
              dpiText.textContent = `Low resolution: ${statusData.preflight.dpi} DPI`;
            }
          }
        } catch (e) { /* ignore */ }
        attempts++;
      }
      
      // Use the signed URL from API, fallback to constructed URL if not available
      const finalUrl = finalDownloadUrl || publicUrl || `https://customizerapp.dev/api/upload/file/${uploadId}`;
      if (uploadUrlInput) uploadUrlInput.value = finalUrl;
      
      // Calculate upload duration
      const uploadDuration = ((Date.now() - startTime) / 1000).toFixed(1);
      
      // Show preview
      progress.style.display = 'none';
      preview.style.display = 'flex';
      if (previewName) previewName.textContent = file.name;
      
      // v4.3.0: Check if non-browser format (needs server-side thumbnail)
      const NON_BROWSER_EXTENSIONS = ['psd', 'pdf', 'ai', 'eps', 'tiff', 'tif'];
      const fileExt = file.name.split('.').pop()?.toLowerCase() || '';
      const isNonBrowserFormat = NON_BROWSER_EXTENSIONS.includes(fileExt);
      
      if (previewImg) {
        if (isNonBrowserFormat) {
          // Non-browser format: Show spinner and poll for thumbnail
          console.log('[UL Quick Upload] Non-browser format detected, showing spinner:', fileExt);
          previewImg.src = 'data:image/svg+xml,' + encodeURIComponent(`
            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 50 50">
              <circle cx="25" cy="25" r="20" fill="none" stroke="#e5e7eb" stroke-width="4"/>
              <circle cx="25" cy="25" r="20" fill="none" stroke="#3b82f6" stroke-width="4" 
                stroke-dasharray="80" stroke-dashoffset="60">
                <animateTransform attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="1s" repeatCount="indefinite"/>
              </circle>
            </svg>
          `);
          previewImg.classList.add('loading-spinner');
          
          // Start background polling for thumbnail
          pollForThumbnail(uploadId, uniqueId, apiBase, shopDomain, previewImg);
        } else if (file.type.startsWith('image/')) {
          // Browser-supported image: Use FileReader for instant preview
          const reader = new FileReader();
          reader.onload = (e) => { previewImg.src = e.target.result; };
          reader.readAsDataURL(file);
        } else {
          // Generic file icon
          previewImg.src = 'data:image/svg+xml,' + encodeURIComponent(`
            <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="#6b7280">
              <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/>
            </svg>
          `);
        }
      }
      
      // Update status badge - always show positive message to customer
      if (previewStatus) {
        previewStatus.textContent = 'Ready for print';
        previewStatus.className = 'ul-status-badge ready';
      }
      
      // Show upload duration
      const previewDuration = document.getElementById('ul-preview-duration-' + uniqueId);
      if (previewDuration) {
        previewDuration.textContent = `Uploaded in ${uploadDuration}s`;
        previewDuration.style.display = 'block';
      }
      
      if (addBtn) addBtn.disabled = false;
      if (hint) hint.style.display = 'none';
      
      // Visitor tracking: dispatch upload complete event
      try {
        window.dispatchEvent(new CustomEvent('ul:upload:complete', {
          detail: {
            uploadId: uploadId,
            productId: productId,
            fileName: file.name,
            fileSize: file.size,
            source: 'quick-upload-btn'
          }
        }));
      } catch (e) { /* Visitor tracking optional */ }
      
    } catch (error) {
      console.error('Upload error:', error);
      progress.style.display = 'none';
      dropzone.style.display = 'block';
      alert('Upload failed: ' + error.message);
    }
  }
  
  // v4.3.0: Poll for server-generated thumbnail (for PSD/PDF/AI/EPS/TIFF)
  async function pollForThumbnail(uploadId, uniqueId, apiBase, shopDomain, imgElement) {
    const MAX_POLLS = 60; // 60 seconds max
    let pollCount = 0;
    
    console.log('[UL Quick Upload] Starting thumbnail polling for:', uploadId);
    
    const doPoll = async () => {
      pollCount++;
      
      if (pollCount > MAX_POLLS) {
        console.log('[UL Quick Upload] Thumbnail polling timeout');
        // Show file icon as fallback
        imgElement.src = 'data:image/svg+xml,' + encodeURIComponent(`
          <svg xmlns="http://www.w3.org/2000/svg" width="48" height="48" viewBox="0 0 24 24" fill="#6b7280">
            <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8l-6-6z"/>
          </svg>
        `);
        imgElement.classList.remove('loading-spinner');
        return;
      }
      
      try {
        const response = await fetch(`${apiBase}/api/upload/status/${uploadId}?shopDomain=${encodeURIComponent(shopDomain)}`);
        
        if (response.ok) {
          const data = await response.json();
          
          if (data.thumbnailUrl) {
            console.log('[UL Quick Upload] Thumbnail received:', data.thumbnailUrl);
            
            // Preload image to avoid flickering
            const img = new Image();
            img.onload = () => {
              imgElement.src = data.thumbnailUrl;
              imgElement.classList.remove('loading-spinner');
            };
            img.onerror = () => {
              console.warn('[UL Quick Upload] Thumbnail load failed, continuing polling');
              setTimeout(doPoll, 1500);
            };
            img.src = data.thumbnailUrl;
            return;
          }
        }
        
        // Continue polling
        setTimeout(doPoll, 1500);
        
      } catch (error) {
        console.warn('[UL Quick Upload] Thumbnail poll error:', error);
        setTimeout(doPoll, 2000);
      }
    };
    
    // Start polling after short delay
    setTimeout(doPoll, 1000);
  }
  
  function cancelUpload(uniqueId) {
    console.log('[UL Quick Upload] Cancelling upload for:', uniqueId);
    
    // Abort active XHR if exists
    if (activeUploads[uniqueId]) {
      activeUploads[uniqueId].abort();
      delete activeUploads[uniqueId];
    }
    
    // Reset UI
    const dropzone = document.getElementById('ul-dropzone-' + uniqueId);
    const progress = document.getElementById('ul-progress-' + uniqueId);
    const progressFill = document.getElementById('ul-progress-fill-' + uniqueId);
    const progressText = document.getElementById('ul-progress-text-' + uniqueId);
    const fileInput = document.getElementById('ul-file-' + uniqueId);
    
    if (progress) progress.style.display = 'none';
    if (dropzone) dropzone.style.display = 'block';
    if (progressFill) progressFill.style.width = '0%';
    if (progressText) progressText.textContent = 'Upload cancelled';
    if (fileInput) fileInput.value = '';
    
    console.log('[UL Quick Upload] Upload cancelled successfully');
  }
  
  function clearUpload(uniqueId, modalId) {
    const dropzone = document.getElementById('ul-dropzone-' + uniqueId);
    const preview = document.getElementById('ul-preview-' + uniqueId);
    const fileInput = document.getElementById('ul-file-' + uniqueId);
    const addBtn = document.getElementById('ul-addcart-' + uniqueId);
    const hint = document.getElementById('ul-hint-' + uniqueId);
    const uploadIdInput = document.getElementById('ul-upload-id-' + uniqueId);
    const dpiWarning = document.getElementById('ul-dpi-warning-' + uniqueId);
    
    if (fileInput) fileInput.value = '';
    if (dropzone) dropzone.style.display = 'block';
    if (preview) preview.style.display = 'none';
    if (dpiWarning) dpiWarning.style.display = 'none';
    if (addBtn) addBtn.disabled = true;
    if (hint) hint.style.display = 'block';
    if (uploadIdInput) uploadIdInput.value = '';
  }
  
  function changeQty(uniqueId, delta) {
    const input = document.getElementById('ul-qty-' + uniqueId);
    if (!input) return;
    let val = parseInt(input.value) || 1;
    val = Math.max(1, Math.min(99, val + delta));
    input.value = val;
    // Update total price when quantity changes
    updateTotalPrice(uniqueId);
  }
  
  // Listen for manual quantity input changes
  document.addEventListener('input', function(e) {
    if (e.target.matches('[id^="ul-qty-"]')) {
      const uniqueId = e.target.id.replace('ul-qty-', '');
      updateTotalPrice(uniqueId);
    }
  });
  
  function updateVariant(uniqueId) {
    const variantsEl = document.getElementById('ul-variants-' + uniqueId);
    if (!variantsEl) {
      console.warn('[Upload Lift] Variant data element not found for:', uniqueId);
      return false;
    }
    
    try {
      const variantsData = JSON.parse(variantsEl.textContent);
      const options = [];
      let i = 0;
      while (document.getElementById('ul-option-' + uniqueId + '-' + i)) {
        const selectEl = document.getElementById('ul-option-' + uniqueId + '-' + i);
        // CRITICAL FIX: Use selectedOptions[0].textContent instead of .value
        // This avoids HTML entity encoding issues with special chars like "
        const selectedOption = selectEl.selectedOptions[0];
        const optionText = selectedOption ? selectedOption.textContent.trim() : selectEl.value;
        options.push(optionText);
        i++;
      }
      
      console.log('[Upload Lift] Selected options (from text):', options);
      console.log('[Upload Lift] Available variants:', variantsData.map(v => ({id: v.id, opt1: v.option1, opt2: v.option2, opt3: v.option3})));
      
      let variant = null;
      
      // If no options (default variant), use first variant
      if (options.length === 0) {
        variant = variantsData[0];
      } else {
        // Find matching variant - compare option text with variant options
        variant = variantsData.find(v => {
          return options.every((opt, idx) => {
            const variantOpt = v['option' + (idx + 1)];
            return variantOpt === opt;
          });
        });
      }
      
      const variantInput = document.getElementById('ul-variant-' + uniqueId);
      
      if (variant) {
        console.log('[Upload Lift] Matched variant:', variant.id, variant.title, 'Price:', variant.price);
        if (variantInput) {
          variantInput.value = variant.id;
          // Store price in data attribute for calculations
          variantInput.dataset.price = variant.price;
        }
        // Update prices
        updateTotalPrice(uniqueId);
        return true;
      } else {
        console.warn('[Upload Lift] No variant match found for options:', options);
        // Fallback: use first available variant
        if (variantsData.length > 0 && variantInput) {
          const fallback = variantsData.find(v => v.available) || variantsData[0];
          console.log('[Upload Lift] Using fallback variant:', fallback.id);
          variantInput.value = fallback.id;
          variantInput.dataset.price = fallback.price;
          updateTotalPrice(uniqueId);
          return true;
        }
      }
      return false;
    } catch (e) {
      console.error('[Upload Lift] Variant update error:', e);
      return false;
    }
  }
  
  // Update total price display
  function updateTotalPrice(uniqueId) {
    console.log('[Upload Lift] updateTotalPrice called for:', uniqueId);
    
    const variantInput = document.getElementById('ul-variant-' + uniqueId);
    const qtyInput = document.getElementById('ul-qty-' + uniqueId);
    const unitPriceEl = document.getElementById('ul-unit-price-' + uniqueId);
    const multiplyEl = document.getElementById('ul-price-multiply-' + uniqueId);
    const totalPriceEl = document.getElementById('ul-total-price-' + uniqueId);
    
    if (!variantInput || !qtyInput || !totalPriceEl) {
      console.warn('[Upload Lift] Missing elements - variantInput:', !!variantInput, 'qtyInput:', !!qtyInput, 'totalPriceEl:', !!totalPriceEl);
      return;
    }
    
    // Get price from data attribute or fetch from variants
    let unitPrice = parseInt(variantInput.dataset.price, 10);
    console.log('[Upload Lift] Price from data attr:', unitPrice);
    
    // If no price in data attribute, get from variants JSON
    if (!unitPrice || isNaN(unitPrice)) {
      const variantsEl = document.getElementById('ul-variants-' + uniqueId);
      if (variantsEl) {
        try {
          const variantsData = JSON.parse(variantsEl.textContent);
          const variant = variantsData.find(v => v.id == variantInput.value);
          if (variant) {
            unitPrice = variant.price;
            variantInput.dataset.price = unitPrice;
            console.log('[Upload Lift] Price from variants JSON:', unitPrice);
          }
        } catch (e) {
          console.error('[Upload Lift] Error parsing variants:', e);
        }
      }
    }
    
    if (!unitPrice || isNaN(unitPrice)) {
      console.warn('[Upload Lift] No valid price found');
      return;
    }
    
    const quantity = parseInt(qtyInput.value, 10) || 1;
    const totalPrice = unitPrice * quantity;
    
    // Update unit price display
    if (unitPriceEl) {
      unitPriceEl.textContent = formatMoney(unitPrice);
    }
    
    // Update multiplier (only show if qty > 1)
    if (multiplyEl) {
      if (quantity > 1) {
        multiplyEl.textContent = '× ' + quantity;
        multiplyEl.style.display = 'inline';
      } else {
        multiplyEl.textContent = '';
        multiplyEl.style.display = 'none';
      }
    }
    
    // Animate total price update
    if (totalPriceEl) {
      totalPriceEl.classList.add('updating');
      totalPriceEl.textContent = formatMoney(totalPrice);
      setTimeout(() => {
        totalPriceEl.classList.remove('updating');
      }, 200);
    }
    
    console.log('[Upload Lift] Price updated - Unit:', formatMoney(unitPrice), 'Qty:', quantity, 'Total:', formatMoney(totalPrice));
  }
  
  // Format money helper - uses Shopify's money format
  function formatMoney(cents) {
    if (typeof cents === 'string') {
      cents = cents.replace('.', '');
    }
    const value = parseInt(cents, 10) / 100;
    // Try to use Shopify's format, fallback to basic format
    if (window.Shopify && window.Shopify.formatMoney) {
      return window.Shopify.formatMoney(cents);
    }
    // Fallback: detect currency from existing price or use default
    const currencySymbol = window.Shopify?.currency?.symbol || '$';
    return currencySymbol + value.toFixed(2);
  }
  
  async function addToCart(uniqueId, modalId) {
    const btn = document.getElementById('ul-addcart-' + uniqueId);
    if (!btn) return;
    
    const btnText = btn.querySelector('.ul-btn-text');
    const btnLoading = btn.querySelector('.ul-btn-loading');
    const variantInput = document.getElementById('ul-variant-' + uniqueId);
    const qtyInput = document.getElementById('ul-qty-' + uniqueId);
    const uploadIdInput = document.getElementById('ul-upload-id-' + uniqueId);
    const uploadUrlInput = document.getElementById('ul-upload-url-' + uniqueId);
    const previewNameEl = document.getElementById('ul-preview-name-' + uniqueId);
    
    // Validate variant ID - ensure it's synced before cart add
    updateVariant(uniqueId);
    
    const variantId = variantInput?.value;
    const quantity = parseInt(qtyInput?.value || '1', 10);
    const uploadId = uploadIdInput?.value;
    const uploadUrl = uploadUrlInput?.value || '';
    const previewName = previewNameEl?.textContent || '';
    
    console.log('[Upload Lift] Add to cart - variantId:', variantId, 'quantity:', quantity, 'uploadId:', uploadId);
    
    // Validation checks
    if (!uploadId) {
      alert('Please upload a design first');
      return;
    }
    
    if (!variantId || variantId === 'undefined' || variantId === 'null') {
      console.error('[Upload Lift] Invalid variant ID:', variantId);
      alert('Please select a valid product variant');
      return;
    }
    
    if (quantity < 1 || quantity > 99) {
      alert('Please enter a valid quantity (1-99)');
      return;
    }
    
    btn.disabled = true;
    if (btnText) btnText.style.display = 'none';
    if (btnLoading) btnLoading.style.display = 'inline';
    
    try {
      const cartPayload = {
        id: parseInt(variantId, 10),
        quantity: quantity,
        properties: {
          // Hidden keys (for internal use)
          '_ul_upload_id': uploadId,
          // Visible keys (shown in checkout)
          'Uploaded File': uploadUrl,
          'File Name': previewName,
          'Design Type': 'DTF Transfer'
        }
      };
      
      console.log('[Upload Lift] Cart payload:', JSON.stringify(cartPayload));
      
      const response = await fetch('/cart/add.js', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(cartPayload)
      });
      
      const responseData = await response.json();
      
      if (!response.ok) {
        // Parse Shopify error response
        const errorMsg = responseData.description || responseData.message || 'Failed to add to cart';
        console.error('[Upload Lift] Shopify cart error:', responseData);
        throw new Error(errorMsg);
      }
      
      console.log('[Upload Lift] Added to cart successfully:', responseData);
      
      // Visitor tracking: dispatch cart add event
      try {
        window.dispatchEvent(new CustomEvent('ul:cart:add', {
          detail: {
            uploadId: uploadId,
            variantId: variantId,
            quantity: quantity,
            productId: responseData.product_id,
            source: 'quick-upload-btn'
          }
        }));
      } catch (e) { /* Visitor tracking optional */ }
      
      // Show success
      const step1 = document.getElementById(modalId + '-step1');
      const step2 = document.getElementById(modalId + '-step2');
      if (step1) step1.style.display = 'none';
      if (step2) step2.style.display = 'block';
      
      // Update cart count
      fetch('/cart.js').then(r => r.json()).then(cart => {
        document.querySelectorAll('.cart-count, .cart-count-bubble span, [data-cart-count]').forEach(el => {
          el.textContent = cart.item_count;
        });
      }).catch(() => {});
      
    } catch (err) {
      console.error('[Upload Lift] Add to cart error:', err);
      alert('Error: ' + err.message);
    } finally {
      btn.disabled = false;
      if (btnText) btnText.style.display = 'inline';
      if (btnLoading) btnLoading.style.display = 'none';
    }
  }
  
  // Expose for backward compatibility
  window.openUploadModal = openModal;
  window.closeUploadModal = closeModal;
})();
</script>